// Code generated by protoc-gen-go. DO NOT EDIT.
// source: counterGrpc.proto

package CounterGrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CounterGrpc struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CounterGrpc) Reset()         { *m = CounterGrpc{} }
func (m *CounterGrpc) String() string { return proto.CompactTextString(m) }
func (*CounterGrpc) ProtoMessage()    {}
func (*CounterGrpc) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a9a235fa2450043, []int{0}
}

func (m *CounterGrpc) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CounterGrpc.Unmarshal(m, b)
}
func (m *CounterGrpc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CounterGrpc.Marshal(b, m, deterministic)
}
func (m *CounterGrpc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CounterGrpc.Merge(m, src)
}
func (m *CounterGrpc) XXX_Size() int {
	return xxx_messageInfo_CounterGrpc.Size(m)
}
func (m *CounterGrpc) XXX_DiscardUnknown() {
	xxx_messageInfo_CounterGrpc.DiscardUnknown(m)
}

var xxx_messageInfo_CounterGrpc proto.InternalMessageInfo

func (m *CounterGrpc) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CounterGrpc) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*CounterGrpc)(nil), "CounterGrpc.counterGrpc")
}

func init() { proto.RegisterFile("counterGrpc.proto", fileDescriptor_9a9a235fa2450043) }

var fileDescriptor_9a9a235fa2450043 = []byte{
	// 127 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4c, 0xce, 0x2f, 0xcd,
	0x2b, 0x49, 0x2d, 0x72, 0x2f, 0x2a, 0x48, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x76,
	0x46, 0x08, 0x29, 0x59, 0x72, 0x71, 0x23, 0xa9, 0x10, 0x12, 0xe1, 0x62, 0x2d, 0xc9, 0xcf, 0x4e,
	0xcd, 0x93, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c, 0x82, 0x70, 0x40, 0xa2, 0x60, 0x45, 0x12, 0x4c,
	0x0a, 0x8c, 0x1a, 0xac, 0x41, 0x10, 0x8e, 0x51, 0x18, 0x17, 0x0f, 0xd4, 0xa4, 0xc0, 0xd2, 0xd4,
	0xd2, 0x54, 0x21, 0x37, 0x2e, 0xbe, 0xa0, 0xd4, 0xc2, 0xd2, 0xd4, 0xe2, 0x12, 0xa8, 0xb0, 0x90,
	0x84, 0x1e, 0x92, 0x55, 0x7a, 0x48, 0xf6, 0x48, 0xe1, 0x94, 0x51, 0x62, 0x48, 0x62, 0x03, 0x3b,
	0xd3, 0x18, 0x10, 0x00, 0x00, 0xff, 0xff, 0x40, 0x7f, 0x52, 0x5c, 0xbb, 0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CounterQueueClient is the client API for CounterQueue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CounterQueueClient interface {
	//for requesting counter
	RequestCounter(ctx context.Context, in *CounterGrpc, opts ...grpc.CallOption) (*CounterGrpc, error)
}

type counterQueueClient struct {
	cc *grpc.ClientConn
}

func NewCounterQueueClient(cc *grpc.ClientConn) CounterQueueClient {
	return &counterQueueClient{cc}
}

func (c *counterQueueClient) RequestCounter(ctx context.Context, in *CounterGrpc, opts ...grpc.CallOption) (*CounterGrpc, error) {
	out := new(CounterGrpc)
	err := c.cc.Invoke(ctx, "/CounterGrpc.CounterQueue/RequestCounter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CounterQueueServer is the server API for CounterQueue service.
type CounterQueueServer interface {
	//for requesting counter
	RequestCounter(context.Context, *CounterGrpc) (*CounterGrpc, error)
}

// UnimplementedCounterQueueServer can be embedded to have forward compatible implementations.
type UnimplementedCounterQueueServer struct {
}

func (*UnimplementedCounterQueueServer) RequestCounter(ctx context.Context, req *CounterGrpc) (*CounterGrpc, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCounter not implemented")
}

func RegisterCounterQueueServer(s *grpc.Server, srv CounterQueueServer) {
	s.RegisterService(&_CounterQueue_serviceDesc, srv)
}

func _CounterQueue_RequestCounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterGrpc)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CounterQueueServer).RequestCounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CounterGrpc.CounterQueue/RequestCounter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CounterQueueServer).RequestCounter(ctx, req.(*CounterGrpc))
	}
	return interceptor(ctx, in, info, handler)
}

var _CounterQueue_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CounterGrpc.CounterQueue",
	HandlerType: (*CounterQueueServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestCounter",
			Handler:    _CounterQueue_RequestCounter_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "counterGrpc.proto",
}
